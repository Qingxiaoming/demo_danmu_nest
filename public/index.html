<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>----</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .draggable-gif {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 2000;
            cursor: move;
            height: 100px; /* 卡片高度 */
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }
        
        /* 音乐播放器样式 */
        .music-player {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
        }
        
        .music-player.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .music-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .music-cover {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            margin-right: 10px;
            object-fit: cover;
        }
        
        .music-details {
            flex: 1;
        }
        
        .music-title {
            font-weight: bold;
            margin: 0 0 5px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .music-artist {
            font-size: 12px;
            color: #666;
            margin: 0;
        }
        
        .music-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .music-progress {
            width: 100%;
            height: 4px;
            background-color: #ddd;
            border-radius: 2px;
            margin: 10px 0;
            position: relative;
        }
        
        .music-progress-bar {
            height: 100%;
            background-color: #007bff;
            border-radius: 2px;
            width: 0;
        }
        
        .music-lyrics {
            margin-top: 10px;
            max-height: 60px;
            overflow-y: auto;
            font-size: 12px;
            text-align: center;
            color: #333;
        }
        
        .current-lyric {
            font-weight: bold;
            color: #007bff;
        }
    </style>
</head>
<body>
    <div id="draggable-gif-container" class="draggable-gif">
        <img src="./-klbw3Qjzp-691xZbT1kSdw-dw.gif" alt="可拖动GIF" height="100">
    </div>
    <h1></h1>
    <div class="login-container">
        <form id="login-form" onsubmit="return false;">
            <input type="password" id="login-password" name="password" placeholder="输入密码" autocomplete="current-password">
            <button type="submit" id="login-btn">Start</button>
        </form>
        <script>
            document.getElementById('login-form').addEventListener('submit', (e) => {
                e.preventDefault();
                document.getElementById('login-btn').click();
            });
        </script>
    </div>
    <div class="toggle-container">
        <button id="toggle-btn" title="切换显示全部/仅等待状态">O</button>
        <div id="password-error" class="error-message"></div>
        <div id="login-status" class="status-message"></div>
        <button id="logout-btn" title="退出登录" style="display: none; margin-left: 10px; background-color: #d9534f; color: white; border: none; border-radius: 3px; padding: 3px 8px; cursor: pointer;">退出</button>
    </div>
    <div id="danmu-container"></div>
    <div class="add-danmu-btn-container" style="display: none;">
        <button id="add-danmu-btn" title="添加弹幕"><i class="fas fa-plus"></i></button>
        <button id="settings-btn" title="设置"><i class="fas fa-cog"></i></button>
    </div>
    <div id="server-error" class="error-message" style="display: none; color: red; font-weight: bold; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; background-color: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);">服务器未连接</div>
    <div id="music-player" class="music-player">
        <div class="music-info">
            <img id="music-cover" class="music-cover" src="" alt="封面">
            <div class="music-details">
                <h3 id="music-title" class="music-title"></h3>
                <p id="music-artist" class="music-artist"></p>
            </div>
        </div>
        <div class="music-progress">
            <div id="music-progress-bar" class="music-progress-bar"></div>
        </div>
        <div class="music-lyrics" id="music-lyrics">
            <p class="current-lyric"></p>
        </div>
        <audio id="music-audio" style="display: none;"></audio>
    </div>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"></script>
    <script>

        const danmuContainer = document.getElementById('danmu-container');
        const serverErrorElement = document.getElementById('server-error'); // 定义全局变量

        const socket = io('http://127.0.0.1:5052', {
            auth: {
                token: localStorage.getItem('auth_token')
            }
        });
        let userRole = localStorage.getItem('auth_token') ? 'owner' : 'guest'; // 根据token判断角色
        let showNonWaiting = true; // 默认显示所有状态
        let currentSelectedDanmuItem = null; // 全局变量，用于追踪当前选中的弹幕项目
        let currentDanmuData = null;// 全局变量存储最新的弹幕数据
        let isConnected = false; // 添加连接状态标志
        let isShowingDialog = false; // 添加对话框显示状态标志

        // 音乐播放器相关变量
        const musicPlayer = document.getElementById('music-player');
        const musicCover = document.getElementById('music-cover');
        const musicTitle = document.getElementById('music-title');
        const musicArtist = document.getElementById('music-artist');
        const musicAudio = document.getElementById('music-audio');
        const musicProgressBar = document.getElementById('music-progress-bar');
        const musicLyrics = document.getElementById('music-lyrics');
        let currentLyrics = [];
        let lyricTimer = null;

        // 页面加载完成后初始化UI状态
        document.addEventListener('DOMContentLoaded', () => {
            // 初始化UI状态
            updateUIByRole();
            
            // 设置登出按钮事件
            document.getElementById('logout-btn').addEventListener('click', logout);
            
            // 检查是否有保存的令牌
            const savedToken = localStorage.getItem('auth_token');
            if (savedToken) {
                // 使用保存的令牌初始化连接
                socket.auth = { token: savedToken };
                console.log('使用保存的令牌初始化连接');
            }
            
            // 处理连接错误
            socket.on('connect_error', (error) => {
                console.error('连接错误:', error);
                // 在UI上显示连接错误
                showConnectionStatus(false, error.message);
            });
            
            // 处理断开连接
            socket.on('disconnect', (reason) => {
                console.log('断开连接:', reason);
                showConnectionStatus(false, reason);
                
                // 如果是服务器断开连接，尝试重新连接
                if (reason === 'io server disconnect') {
                    // 服务器断开连接，需要手动重连
                    setTimeout(() => {
                        console.log('尝试重新连接...');
                        socket.connect();
                    }, 3000);
                }
                // 其他断开原因会自动重连
            });
            
            // 处理重新连接
            socket.on('reconnect', (attemptNumber) => {
                console.log('重新连接成功，尝试次数:', attemptNumber);
                showConnectionStatus(true);
            });
            
            // 处理重新连接尝试
            socket.on('reconnect_attempt', (attemptNumber) => {
                console.log('尝试重新连接，次数:', attemptNumber);
                showConnectionStatus(false, `尝试重新连接 (${attemptNumber})`);
            });
            
            // 处理重新连接错误
            socket.on('reconnect_error', (error) => {
                console.error('重新连接错误:', error);
                showConnectionStatus(false, `重新连接错误: ${error.message}`);
            });
            
            // 处理重新连接失败
            socket.on('reconnect_failed', () => {
                console.error('重新连接失败');
                showConnectionStatus(false, '重新连接失败，请刷新页面');
            });
            
            // 连接状态显示
            socket.on('connect', () => {
                console.log('连接成功');
                showConnectionStatus(true);
            });
        });

        // 根据用户角色更新UI
        function updateUIByRole() {
            const addDanmuBtnContainer = document.querySelector('.add-danmu-btn-container');
            const logoutBtn = document.getElementById('logout-btn');
            
            if (userRole === 'owner') {
                addDanmuBtnContainer.style.display = 'block';
                logoutBtn.style.display = 'inline-block';
                updateLoginStatus('已登录', '#5cb85c');
            } else {
                addDanmuBtnContainer.style.display = 'none';
                logoutBtn.style.display = 'none';
                updateLoginStatus('未登录', '#ff5722');
            }
        }

        // 更新登录状态显示
        function updateLoginStatus(text, color) {
            const loginStatus = document.getElementById('login-status');
            loginStatus.textContent = text;
            loginStatus.style.color = color;
        }

        // 显示连接状态的函数
        function showConnectionStatus(connected, message = '') {
            // 检查状态指示器是否存在，不存在则创建
            let statusIndicator = document.getElementById('connection-status');
            if (!statusIndicator) {
                statusIndicator = document.createElement('div');
                statusIndicator.id = 'connection-status';
                statusIndicator.style.position = 'fixed';
                statusIndicator.style.bottom = '10px';
                statusIndicator.style.right = '10px';
                statusIndicator.style.padding = '5px 10px';
                statusIndicator.style.borderRadius = '5px';
                statusIndicator.style.fontSize = '12px';
                statusIndicator.style.zIndex = '1000';
                document.body.appendChild(statusIndicator);
            }
            
            if (connected) {
                statusIndicator.style.backgroundColor = '#5cb85c';
                statusIndicator.style.color = 'white';
                statusIndicator.textContent = '已连接';
                
                // 连接成功后3秒隐藏
                setTimeout(() => {
                    statusIndicator.style.opacity = '0.5';
                }, 3000);
            } else {
                statusIndicator.style.backgroundColor = '#d9534f';
                statusIndicator.style.color = 'white';
                statusIndicator.style.opacity = '1';
                statusIndicator.textContent = message ? `未连接: ${message}` : '未连接';
            }
        }

        // 显示认证错误提示
        function showAuthError(message) {
            const errorElement = document.getElementById('password-error');
            errorElement.textContent = message || '需要登录才能执行此操作';
            errorElement.classList.add('show');
            setTimeout(() => {
                errorElement.classList.remove('show');
            }, 3000);
        }

        // 初始化Socket事件监听
        setupSocketEvents();

        // 添加点击列表外失焦的逻辑
        document.addEventListener('click', (e) => {
            // 检查点击是否发生在弹幕项目外部
            if (currentSelectedDanmuItem && !e.target.closest('.danmu-item') && !e.target.closest('.acps-dialog') && !e.target.closest('.acps-dialog-overlay')) {
                // 如果点击在弹幕项目外部且不在对话框内，取消选中状态
                currentSelectedDanmuItem.classList.remove('selected');
                currentSelectedDanmuItem.blur();
                currentSelectedDanmuItem = null;
            }
        });

        // 全局快捷键监听
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key.toLowerCase() === 'i') {
                e.preventDefault();
                showSettingsDialog();
            } else if (e.ctrlKey && e.key.toLowerCase() === 'a') {
                e.preventDefault();
                showAddDanmuDialog();
            } else if (e.ctrlKey && e.key.toLowerCase() === 't') {
                e.preventDefault();
                document.getElementById('toggle-btn').click();
            }
        });
        // 设置按钮点击事件
        document.getElementById('settings-btn').onclick = () => {
            showSettingsDialog();
        };
        // 添加弹幕按钮点击事件
        document.getElementById('add-danmu-btn').onclick = () => {
            showAddDanmuDialog();
        };

        //切换列表显示函数
        document.getElementById('toggle-btn').onclick = () => {
            showNonWaiting = !showNonWaiting; // 切换显示/隐藏状态
            renderDanmu(); // 重新渲染弹幕
        };

        // 处理弹幕项选择的通用函数
        function handleDanmuItemSelection(item) {
            if (currentSelectedDanmuItem && (currentSelectedDanmuItem !== item)) {
                currentSelectedDanmuItem.classList.remove('selected');
                //currentSelectedDanmuItem.blur();
            }
            item.classList.add('selected');
            item.focus();
            currentSelectedDanmuItem = item;
        }

        // 检查是否有权限执行管理员操作
        function checkAdminPermission() {
            if (userRole !== 'owner') {
                showAuthError();
                return false;
            }
            return true;
        }

        // 处理Tab键导航的通用函数
        function handleTabNavigation(item, e) {
            e.preventDefault();
            const items = Array.from(document.querySelectorAll('.danmu-item'));
            const currentIndex = items.indexOf(item);
            let nextIndex;
            if (e.shiftKey) {
                nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
            } else {
                nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
            }
            const nextItem = items[nextIndex];
            if (nextItem) {
                handleDanmuItemSelection(nextItem);
            }
        }

        //管理员id验证函数
        document.getElementById('login-btn').onclick = () => {
            const plainPassword = document.getElementById('login-password').value;
            if (!plainPassword) {
                const errorElement = document.getElementById('password-error');
                errorElement.textContent = '密码为空';
                errorElement.classList.add('show');
                setTimeout(() => {
                    errorElement.classList.remove('show');
                }, 3000);
                return;
            }
            
            // 显示登录中状态
            const loginStatus = document.getElementById('login-status');
            loginStatus.textContent = '登录中...';
            loginStatus.style.color = '#5bc0de';
            
            // 使用SHA-256对密码进行加密
            const hashedPassword = CryptoJS.SHA256(plainPassword).toString();
            console.log('发送SHA-256哈希密码进行验证');
            
            // 发送加密后的密码到后端进行验证，不再发送isHashed参数
            socket.emit('verify_password', { password: hashedPassword });
            
            socket.once('verify_password', (response) => {
                console.log('收到验证响应:', response);
                
                if (response.success && response.token) {
                    console.log('验证成功,保存JWT令牌');
                    
                    // 保存JWT令牌
                    localStorage.setItem('auth_token', response.token);
                    console.log('JWT令牌已保存到localStorage');
                    
                    // 更新socket连接的认证信息
                    socket.auth = { token: response.token };
                    
                    // 断开并重新连接以应用新的认证信息
                    if (socket.connected) {
                        socket.disconnect().connect();
                        console.log('断开并重新连接以应用新的认证信息');
                    } else {
                        socket.connect();
                        console.log('连接Socket以应用认证信息');
                    }
                    
                    userRole = 'owner';
                    updateUIByRole();
                    renderDanmu();
                    
                    // 清空密码输入框
                    document.getElementById('login-password').value = '';
                    
                    // 显示登录成功消息
                    const errorElement = document.getElementById('password-error');
                    errorElement.textContent = '登录成功！';
                    errorElement.style.color = '#5cb85c';
                    errorElement.classList.add('show');
                    setTimeout(() => {
                        errorElement.classList.remove('show');
                        errorElement.style.color = '#d9534f'; // 恢复错误消息的颜色
                    }, 3000);
                } else {
                    // 处理验证失败
                    const errorElement = document.getElementById('password-error');
                    errorElement.textContent = response.message || '验证失败';
                    errorElement.classList.add('show');
                    setTimeout(() => {
                        errorElement.classList.remove('show');
                    }, 3000);
                }
            });
        };

        // 使用函数封装Socket.IO事件处理逻辑
        function setupSocketEvents() {
            // 定义所有需要监听的事件
            const socketEvents = [
                'update', 'get_acps', 'update_acps', 'add_danmu', 'play_song'
            ];
            // 为每个事件添加监听器
            socketEvents.forEach(eventName => {
                socket.on(eventName, (data) => {
                    handleSocketEvent(eventName, data);
                });
            });
        }
        
        // 使用switch-case处理不同的Socket.IO事件
        function handleSocketEvent(eventName, data) {
            switch(eventName) {
                case 'update':
                    currentDanmuData = data; // 保存最新数据
                    // 只有在没有显示对话框时才重新渲染
                    if (!isShowingDialog) {
                        renderDanmu(data);
                    }
                    break;
                    
                case 'get_acps':
                    console.log('收到账密数据:', data);
                    if (data && data.data) {
                        showAccountPasswordDialog(data.data, data.uid);
                    }
                    break;
                    
                case 'update_acps':
                    break;
                    
                case 'add_danmu':
                    break;
                    
                case 'play_song':
                    console.log('收到点歌请求:', data);
                    if (data && data.success && data.song) {
                        playSong(data.song);
                    }
                    break;
                    
                default:
                    console.log(`未处理的事件: ${eventName}`, data);
                    break;
            }
        }
        
        function renderDanmu(data) {
            // 如果没有传入数据，使用最新保存的数据
            if (!data) {
                data = currentDanmuData;
            }
            // 如果没有数据可用，直接返回
            if (!data || !data.uid) return;
            
            // 根据用户角色控制右下角按钮的显示/隐藏
            updateUIByRole();
            
            // 保存当前选中项的信息
            let selectedUid = null;
            if (currentSelectedDanmuItem) {
                // 获取当前选中项的uid属性
                selectedUid = currentSelectedDanmuItem.getAttribute('data-uid');
                // 如果没有uid属性，尝试通过索引获取
                if (!selectedUid) {
                    const items = Array.from(document.querySelectorAll('.danmu-item'));
                    const selectedIndex = items.indexOf(currentSelectedDanmuItem);
                    if (selectedIndex !== -1 && selectedIndex < data.uid.length) {
                        selectedUid = data.uid[selectedIndex];
                    }
                }
            }
            
            danmuContainer.innerHTML = ''; // 清空现有内容
            data.uid.forEach((uid, index) => {
                if (!showNonWaiting && data.status[index] !== 'waiting') {
                    return; // 如果隐藏非等待状态且当前状态不是 'waiting'，则跳过
                }
                // 如果状态为notdisplay，跳过该项不显示
                if (data.status[index] === 'notdisplay') {
                    return;
                }
                const item = document.createElement('div');
                item.className = 'danmu-item';
                // 添加点击事件处理
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleDanmuItemSelection(item);
                });
                // 修改tabIndex以支持Tab键导航
                item.tabIndex = 0;
                // 优化Tab键导航
                item.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        handleTabNavigation(item, e);
                    } else if (userRole === 'owner' && (e.key === '1' || e.key === '2' || e.key === '3' || e.key === '4')) {
                        switch(e.key) {
                            case '1':
                                socket.emit('delete', { index: uid });
                                break;
                            case '2':
                                socket.emit('completed', { index: uid });
                                break;
                            case '3':
                                const newText = prompt('请输入新的弹幕内容:', data.text[index]);
                                if (newText) {
                                    socket.emit('edit', { index: uid, text: newText });
                                }
                                break;
                            case '4':
                                socket.emit('get_acps', { index: uid });
                                break;
                        }
                    }
                });

                // 添加焦点事件处理
                item.addEventListener('focus', () => {
                    handleDanmuItemSelection(item);
                });
                
                // 存储uid属性，用于后续恢复选中状态
                item.setAttribute('data-uid', uid);

                // 昵称
                const nickname = document.createElement('span');
                nickname.textContent = `${data.nickname[index]}: `;
                nickname.className = 'nickname';

                // 弹幕内容
                const text = document.createElement('span');
                text.textContent = `${data.text[index]}`;
                text.className = 'text';

                // 状态
                const status = document.createElement('span');
                status.textContent = `      ${data.status[index]}`;
                status.className = 'status';

                // 创建时间
                const createtime = document.createElement('span');
                createtime.textContent = `----${data.createtime[index].slice(5, 16)}`;
                createtime.className = 'createtime';

                // 只有认证用户才能看到操作按钮
                if (userRole === 'owner') {
                    const actions = document.createElement('div');
                    actions.className = 'actions';

                    // 删除按钮
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '删除';
                    deleteBtn.onclick = () => {
                        socket.emit('delete', {
                            index: uid 
                        });
                    };

                    // 编辑按钮
                    const editBtn = document.createElement('button');
                    editBtn.textContent = '编辑';
                    editBtn.onclick = () => {
                        const newText = prompt('请输入新的弹幕内容:', data.text[index]);
                        if (newText) {
                            socket.emit('edit', {
                                index: uid, 
                                text: newText
                            });
                        }
                    };

                    // 完成按钮
                    const completedBtn = document.createElement('button');
                    completedBtn.textContent = '完成';
                    completedBtn.onclick = () => {
                        socket.emit('completed', {
                            index: uid 
                        });
                    };
                    // 账密按钮
                    const ac_ps_Btn = document.createElement('button');
                    ac_ps_Btn.textContent = '账密';
                    ac_ps_Btn.onclick = () => {
                        // 然后发送WebSocket事件获取数据
                        socket.emit('get_acps', {
                            index: uid
                        });
                    };
                    
                    actions.appendChild(deleteBtn);
                    actions.appendChild(completedBtn);
                    actions.appendChild(editBtn);
                    actions.appendChild(ac_ps_Btn);
                    item.appendChild(actions);
                }

                item.appendChild(nickname);
                item.appendChild(text);
                item.appendChild(status);
                item.appendChild(createtime);

                danmuContainer.appendChild(item);
                
                // 如果这个项目是之前选中的项目，恢复选中状态
                if (selectedUid && uid === selectedUid) {
                    currentSelectedDanmuItem = item;
                    item.classList.add('selected');
                    // 使用setTimeout确保DOM完全渲染后再设置焦点
                    setTimeout(() => {
                        item.focus();
                    }, 0);
                }
            });
            
            // 如果渲染后没有找到之前选中的项目（可能因为过滤或其他原因），但有其他项目可选
            if (selectedUid && !currentSelectedDanmuItem && danmuContainer.children.length > 0) {
                // 选择第一个可见的项目
                const firstItem = danmuContainer.children[0];
                currentSelectedDanmuItem = firstItem;
                firstItem.classList.add('selected');
                setTimeout(() => {
                    firstItem.focus();
                }, 0);
            }
        }

        // 显示添加弹幕对话框
        function showAddDanmuDialog() {
            if (!checkAdminPermission()) return;
            
            // 设置对话框显示状态为true
            isShowingDialog = true;
            
            const overlay = document.createElement('div');
            overlay.className = 'acps-dialog-overlay';
            document.body.appendChild(overlay);

            const dialog = document.createElement('div');
            dialog.className = 'acps-dialog';
            dialog.innerHTML = `
                <h3>添加弹幕</h3>
                <input type="text" id="add-nickname" placeholder="输入昵称">
                <input type="text" id="add-text" placeholder="输入弹幕内容">
                <button id="add-save">保存</button>
                <button id="add-cancel">取消</button>
            `;

            // 添加延时以触发动画
            requestAnimationFrame(() => {
                overlay.classList.add('show');
                dialog.classList.add('show');
            });

            const saveButton = dialog.querySelector('#add-save');
            const cancelButton = dialog.querySelector('#add-cancel');
            const nicknameField = dialog.querySelector('#add-nickname');
            const textField = dialog.querySelector('#add-text');

            // 添加键盘事件监听
            const handleKeydown = (e) => {
                if (e.key === 'Enter') {
                    saveButton.click();
                } else if (e.key === 'Escape') {
                    cancelButton.click();
                }
            };
            document.addEventListener('keydown', handleKeydown);

            // 在保存弹幕时进行输入验证
            function validateInput(text) {
                if (!text || text.length > 500) {
                    return false;
                }
                // 检查是否包含恶意内容
                const maliciousPatterns = /<script|javascript:|onerror=|onclick=/i;
                return !maliciousPatterns.test(text);
            }

            // 在提交前验证
            saveButton.onclick = () => {
                const nickname = nicknameField.value;
                const text = textField.value;
                if (nickname && text && validateInput(nickname) && validateInput(text)) {
                    socket.emit('add_danmu', {
                        nickname: DOMPurify.sanitize(nickname),
                        text: DOMPurify.sanitize(text)
                    });
                    closeDialog();
                } else {
                    alert('输入内容无效或过长');
                }
            };

            cancelButton.onclick = () => {
                closeDialog();
            };

            const closeDialog = () => {
                document.removeEventListener('keydown', handleKeydown);
                overlay.classList.remove('show');
                dialog.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    dialog.remove();
                    // 设置对话框显示状态为false
                    isShowingDialog = false;
                    // 关闭对话框后重新渲染一次，确保数据是最新的
                    renderDanmu(currentDanmuData);
                }, 300);
            };

            document.body.appendChild(dialog);
        }

        // 读取本地存储中的快捷键设置
        function loadShortcutSettings() {
            const settings = localStorage.getItem('shortcutSettings');
            return settings ? JSON.parse(settings) : {};
        }

        // 保存快捷键设置到本地存储
        function saveShortcutSettings(settings) {
            console.log('保存快捷键设置:', settings); // 调试输出
            localStorage.setItem('shortcutSettings', JSON.stringify(settings));
        }

        // 初始化快捷键设置
        let shortcutSettings = loadShortcutSettings();

        // 确保在 DOMContentLoaded 事件后初始化
        document.addEventListener('DOMContentLoaded', () => {
            shortcutSettings = loadShortcutSettings();
        });

        // 绑定快捷键到功能
        document.addEventListener('keydown', (e) => {
            const keyCombination = [];
            if (e.ctrlKey) keyCombination.push('Ctrl');
            if (e.shiftKey) keyCombination.push('Shift');
            if (e.altKey) keyCombination.push('Alt');
            if (e.key !== 'Control' && e.key !== 'Shift' && e.key !== 'Alt') {
                keyCombination.push(e.key.toUpperCase());
            }
            const keyString = keyCombination.join('+');

            switch (keyString) {
                case shortcutSettings.delete:
                    // 执行删除操作
                    console.log('执行删除操作');
                    break;
                case shortcutSettings.complete:
                    // 执行完成操作
                    console.log('执行完成操作');
                    break;
                case shortcutSettings.edit:
                    // 执行编辑操作
                    console.log('执行编辑操作');
                    break;
                case shortcutSettings.acps:
                    // 执行账密操作
                    console.log('执行账密操作');
                    break;
                case shortcutSettings.add:
                    // 执行增加操作
                    console.log('执行增加操作');
                    break;
            }
        });

        // 更新设置界面
        function showSettingsDialog() {
            if (!checkAdminPermission()) return;
            
            // 设置对话框显示状态为true
            isShowingDialog = true;
            
            const overlay = document.createElement('div');
            overlay.className = 'acps-dialog-overlay';
            document.body.appendChild(overlay);

            const dialog = document.createElement('div');
            dialog.className = 'acps-dialog';
            dialog.innerHTML = `
                <h3>快捷键设置</h3>
                <div class="settings-item">
                    <label>删除快捷键：</label>
                    <input type="text" id="delete-shortcut" placeholder="请按下快捷键组合" readonly value="${shortcutSettings.delete || ''}">
                </div>
                <div class="settings-item">
                    <label>完成快捷键：</label>
                    <input type="text" id="complete-shortcut" placeholder="请按下快捷键组合" readonly value="${shortcutSettings.complete || ''}">
                </div>
                <div class="settings-item">
                    <label>编辑快捷键：</label>
                    <input type="text" id="edit-shortcut" placeholder="请按下快捷键组合" readonly value="${shortcutSettings.edit || ''}">
                </div>
                <div class="settings-item">
                    <label>账密快捷键：</label>
                    <input type="text" id="acps-shortcut" placeholder="请按下快捷键组合" readonly value="${shortcutSettings.acps || ''}">
                </div>
                <div class="settings-item">
                    <label>增加快捷键：</label>
                    <input type="text" id="add-shortcut" placeholder="请按下快捷键组合" readonly value="${shortcutSettings.add || ''}">
                </div>
                <div class="settings-actions">
                    <button id="settings-save">保存</button>
                    <button id="settings-cancel">取消</button>
                </div>
            `;

            requestAnimationFrame(() => {
                overlay.classList.add('show');
                dialog.classList.add('show');
            });

            const closeDialog = () => {
                overlay.classList.remove('show');
                dialog.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    dialog.remove();
                    // 设置对话框显示状态为false
                    isShowingDialog = false;
                    // 关闭对话框后重新渲染一次，确保数据是最新的
                    renderDanmu(currentDanmuData);
                }, 300);
            };

            // 快捷键输入处理
            const shortcutInputs = dialog.querySelectorAll('input[type="text"]');
            shortcutInputs.forEach(input => {
                input.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    const keys = [];
                    if (e.ctrlKey) keys.push('Ctrl');
                    if (e.shiftKey) keys.push('Shift');
                    if (e.altKey) keys.push('Alt');
                    if (e.key !== 'Control' && e.key !== 'Shift' && e.key !== 'Alt') {
                        keys.push(e.key.toUpperCase());
                    }
                    input.value = keys.join('+');
                });
            });

            dialog.querySelector('#settings-save').onclick = () => {
                const newSettings = {
                    delete: document.getElementById('delete-shortcut').value,
                    complete: document.getElementById('complete-shortcut').value,
                    edit: document.getElementById('edit-shortcut').value,
                    acps: document.getElementById('acps-shortcut').value,
                    add: document.getElementById('add-shortcut').value
                };
                console.log('保存按钮点击，新的设置:', newSettings); // 调试输出
                saveShortcutSettings(newSettings);
                closeDialog();
            };

            dialog.querySelector('#settings-cancel').onclick = closeDialog;

            document.body.appendChild(dialog);
        }
        //账密显示函数
        function showAccountPasswordDialog(data, uid) {
            // 设置对话框显示状态为true
            isShowingDialog = true;
            
            const overlay = document.createElement('div');
            overlay.className = 'acps-dialog-overlay';
            document.body.appendChild(overlay);

            const dialog = document.createElement('div');
            dialog.className = 'acps-dialog';
            dialog.innerHTML = `
                <h3>账号密码信息</h3>
                <div class="acps-content">
                    <div class="acps-display-mode">
                        <p><strong>账号：</strong><span id="current-account">${data.account}</span></p>
                        <p><strong>密码：</strong><span id="current-password">${data.password}</span></p>
                        <div class="acps-buttons">
                            <button id="acps-copy" title="复制到剪贴板 (C)"><i class="fas fa-copy"></i> 复制</button>
                            <button id="acps-edit-mode" title="编辑模式 (R)"><i class="fas fa-edit"></i> 编辑</button>
                            <button id="acps-cancel">取消</button>
                        </div>
                    </div>
                    <div class="acps-edit-mode" style="display: none;">
                        <p><strong>账号：</strong><input type="text" id="edit-account" value="${data.account}"></p>
                        <p><strong>密码：</strong><input type="text" id="edit-password" value="${data.password}"></p>
                        <div class="acps-buttons">
                            <button id="acps-save"><i class="fas fa-save"></i> 保存</button>
                            <button id="acps-cancel-edit"><i class="fas fa-times"></i> 取消</button>
                        </div>
                    </div>
                </div>
            `;

            // 添加延时以触发动画
            requestAnimationFrame(() => {
                overlay.classList.add('show');
                dialog.classList.add('show');
            });

            // 获取DOM元素
            const displayMode = dialog.querySelector('.acps-display-mode');
            const editMode = dialog.querySelector('.acps-edit-mode');
            const copyBtn = dialog.querySelector('#acps-copy');
            const editModeBtn = dialog.querySelector('#acps-edit-mode');
            const saveBtn = dialog.querySelector('#acps-save');
            const cancelBtn = dialog.querySelector('#acps-cancel');
            const cancelEditBtn = dialog.querySelector('#acps-cancel-edit');

            // 复制到剪贴板功能
            copyBtn.onclick = () => {
                const accountText = data.account;
                const passwordText = data.password;
                
                // 创建两个临时输入框，用于分别复制账号和密码
                const accountInput = document.createElement('input');
                accountInput.value = accountText;
                document.body.appendChild(accountInput);
                accountInput.select();
                document.execCommand('copy');
                document.body.removeChild(accountInput);
                
                // 显示复制账号成功提示
                const copyAccountSuccess = document.createElement('div');
                copyAccountSuccess.textContent = '账号复制成功！';
                copyAccountSuccess.style.color = 'green';
                copyAccountSuccess.style.marginTop = '10px';
                copyAccountSuccess.style.textAlign = 'center';
                
                // 如果已经有提示，则移除
                const existingSuccess = dialog.querySelector('.copy-success');
                if (existingSuccess) {
                    existingSuccess.remove();
                }
                
                copyAccountSuccess.className = 'copy-success';
                displayMode.appendChild(copyAccountSuccess);
                
                // 1秒后复制密码
                setTimeout(() => {
                    const passwordInput = document.createElement('input');
                    passwordInput.value = passwordText;
                    document.body.appendChild(passwordInput);
                    passwordInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(passwordInput);
                    
                    // 更新提示为密码复制成功
                    copyAccountSuccess.textContent = '密码复制成功！';
                    
                    // 2秒后移除提示
                    setTimeout(() => {
                        copyAccountSuccess.remove();
                    }, 2000);
                }, 1000);
            };

            // 切换到编辑模式
            editModeBtn.onclick = () => {
                displayMode.style.display = 'none';
                editMode.style.display = 'block';
            };

            // 保存编辑
            saveBtn.onclick = () => {
                const newAccount = dialog.querySelector('#edit-account').value;
                const newPassword = dialog.querySelector('#edit-password').value;
                
                if (newAccount && newPassword) {
                    // 更新数据
                    data.account = newAccount;
                    data.password = newPassword;
                    
                    // 发送到后端，按照后端期望的格式发送
                    socket.emit('update_acps', {
                        index: uid,
                        text: `${newAccount} / ${newPassword}`
                    });
                    
                    // 更新显示
                    dialog.querySelector('#current-account').textContent = newAccount;
                    dialog.querySelector('#current-password').textContent = newPassword;
                    
                    // 切回显示模式
                    editMode.style.display = 'none';
                    displayMode.style.display = 'block';
                } else {
                    alert('账号和密码不能为空');
                }
            };

            // 取消编辑，返回显示模式
            cancelEditBtn.onclick = () => {
                editMode.style.display = 'none';
                displayMode.style.display = 'block';
            };

            // 关闭对话框
            cancelBtn.onclick = () => {
                closeDialog();
            };

            // 添加键盘事件监听
            const handleKeydown = (e) => {
                if (e.key.toLowerCase() === 'c') {
                    // 按C复制
                    copyBtn.click();
                } else if (e.key.toLowerCase() === 'r') {
                    // 按R进入编辑模式
                    if (displayMode.style.display !== 'none') {
                        editModeBtn.click();
                    }
                } else if (e.key === 'Escape') {
                    // ESC关闭对话框或返回显示模式
                    if (editMode.style.display !== 'none') {
                        cancelEditBtn.click();
                    } else {
                        cancelBtn.click();
                    }
                } else if (e.key === 'Enter') {
                    // Enter保存编辑或在显示模式下复制
                    if (editMode.style.display !== 'none') {
                        saveBtn.click();
                    } else {
                        copyBtn.click();
                    }
                }
            };
            
            document.addEventListener('keydown', handleKeydown);

            // 关闭弹出对话框
            const closeDialog = () => {
                document.removeEventListener('keydown', handleKeydown);
                overlay.classList.remove('show');
                dialog.classList.remove('show');
                setTimeout(() => {
                    overlay.remove();
                    dialog.remove();
                    // 设置对话框显示状态为false
                    isShowingDialog = false;
                    // 关闭对话框后重新渲染一次，确保数据是最新的
                    renderDanmu(currentDanmuData);
                }, 300);
            };

            document.body.appendChild(dialog);
        }

        // 拖动GIF的功能
        const dragElement = document.getElementById("draggable-gif-container");
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        if (dragElement) {
            dragElement.onmousedown = dragMouseDown;
        }
        
        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // 获取鼠标位置
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // 鼠标移动时调用elementDrag函数
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // 计算新位置
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // 设置元素的新位置
            dragElement.style.top = (dragElement.offsetTop - pos2) + "px";
            dragElement.style.left = (dragElement.offsetLeft - pos1) + "px";
        }
        
        function closeDragElement() {
            // 停止移动
            document.onmouseup = null;
            document.onmousemove = null;
        }

        // 登出功能
        function logout() {
            // 删除localStorage中的token
            localStorage.removeItem('auth_token');
            
            // 更新用户角色
            userRole = 'guest';
            
            // 更新UI显示
            updateUIByRole();
            
            // 断开并重新连接WebSocket（以访客模式）
            if (socket.connected) {
                socket.auth = {}; // 清空认证信息
                socket.disconnect().connect();
            }
            
            // 显示登出成功消息
            const errorElement = document.getElementById('password-error');
            errorElement.textContent = '已成功退出登录';
            errorElement.style.color = '#5bc0de';
            errorElement.classList.add('show');
            setTimeout(() => {
                errorElement.classList.remove('show');
                errorElement.style.color = '#d9534f'; // 恢复错误消息的颜色
            }, 3000);
            
            console.log('用户已登出，认证信息已清除');
        }

        // 播放歌曲
        function playSong(song) {
            // 设置歌曲信息
            musicTitle.textContent = song.name;
            musicArtist.textContent = song.artist;
            musicCover.src = song.cover || 'default-cover.jpg';
            
            // 检查是否有错误信息
            if (song.error) {
                console.error('歌曲信息获取失败:', song.error.message, '错误码:', song.error.code);
                // 显示错误提示
                musicLyrics.innerHTML = `<p class="current-lyric" style="color: #d9534f;">无法播放：${song.error.message}</p>`;
                musicPlayer.classList.add('show');
                
                // 3秒后隐藏播放器
                setTimeout(() => {
                    musicPlayer.classList.remove('show');
                }, 3000);
                return;
            }
            
            // 检查URL是否存在
            if (!song.url) {
                console.error('歌曲URL不存在，无法播放:', song.name);
                // 显示错误提示
                musicLyrics.innerHTML = '<p class="current-lyric" style="color: #d9534f;">无法播放：获取歌曲URL失败</p>';
                musicPlayer.classList.add('show');
                
                // 3秒后隐藏播放器
                setTimeout(() => {
                    musicPlayer.classList.remove('show');
                }, 3000);
                return;
            }
            
            // 设置音频源
            musicAudio.src = song.url;
            
            // 解析歌词
            parseLyrics(song.lrc || '');
            
            // 显示播放器
            musicPlayer.classList.add('show');
            
            // 播放音乐
            musicAudio.play().catch(error => {
                console.error('播放音乐失败:', error);
                // 显示错误提示
                musicLyrics.innerHTML = '<p class="current-lyric" style="color: #d9534f;">播放失败：' + error.message + '</p>';
                
                // 3秒后隐藏播放器
                setTimeout(() => {
                    musicPlayer.classList.remove('show');
                }, 3000);
            });
            
            // 更新进度条
            musicAudio.addEventListener('timeupdate', updateProgress);
            
            // 歌曲播放结束时隐藏播放器
            musicAudio.addEventListener('ended', () => {
                musicPlayer.classList.remove('show');
                clearInterval(lyricTimer);
            });
            
            // 开始歌词滚动
            startLyricScroll();
        }
        
        // 更新进度条
        function updateProgress() {
            if (musicAudio.duration) {
                const progress = (musicAudio.currentTime / musicAudio.duration) * 100;
                musicProgressBar.style.width = `${progress}%`;
            }
        }
        
        // 解析LRC格式歌词
        function parseLyrics(lrcText) {
            currentLyrics = [];
            musicLyrics.innerHTML = '';
            
            if (!lrcText) {
                musicLyrics.innerHTML = '<p class="current-lyric">暂无歌词</p>';
                return;
            }
            
            try {
                const lines = lrcText.split('\n');
                const pattern = /\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/;
                
                lines.forEach(line => {
                    const match = line.match(pattern);
                    if (match) {
                        const minutes = parseInt(match[1]);
                        const seconds = parseInt(match[2]);
                        const milliseconds = parseInt(match[3]);
                        const text = match[4].trim();
                        
                        if (text) {
                            const time = minutes * 60 + seconds + milliseconds / 1000;
                            currentLyrics.push({ time, text });
                        }
                    }
                });
                
                // 按时间排序
                currentLyrics.sort((a, b) => a.time - b.time);
                
                // 初始显示第一句歌词
                if (currentLyrics.length > 0) {
                    musicLyrics.innerHTML = `<p class="current-lyric">${currentLyrics[0].text}</p>`;
                } else {
                    musicLyrics.innerHTML = '<p class="current-lyric">暂无歌词</p>';
                }
            } catch (error) {
                console.error('解析歌词失败:', error);
                musicLyrics.innerHTML = '<p class="current-lyric">歌词解析失败</p>';
            }
        }
        
        // 开始歌词滚动
        function startLyricScroll() {
            clearInterval(lyricTimer);
            
            if (currentLyrics.length === 0) return;
            
            lyricTimer = setInterval(() => {
                try {
                    const currentTime = musicAudio.currentTime;
                    let currentLyric = '';
                    
                    // 查找当前时间对应的歌词
                    for (let i = 0; i < currentLyrics.length; i++) {
                        if (i === currentLyrics.length - 1 || 
                            (currentTime >= currentLyrics[i].time && currentTime < currentLyrics[i + 1].time)) {
                            currentLyric = currentLyrics[i].text;
                            break;
                        }
                    }
                    
                    if (currentLyric) {
                        musicLyrics.innerHTML = `<p class="current-lyric">${currentLyric}</p>`;
                    }
                } catch (error) {
                    console.error('歌词滚动出错:', error);
                    clearInterval(lyricTimer);
                }
            }, 100);
        }

    </script>
</body>
</html>
